I"<blockquote>
  <p>在开发中，我们经常会遇到一种情况，就是安装的依赖包有个地方有个小 bug，也没有足够的时间等作者处理 pr。这时候，一些硬核的朋友会把源码拷贝到开发目录中进行修改;文明一些的朋友会将修改后的代码，改个名字，发布一个新包~ 那么，有没有更优雅的方法处理这种情况呢？</p>
</blockquote>

<h3 id="patch-package-能解决问题">patch-package 能解决问题</h3>

<h4 id="实现过程">实现过程：</h4>

<p>如果你修改了库 A，patch-package 可以帮你生成一份补丁。下次再安装库 A 的时候，patch-package 会根据补丁，自动将修改注入到 node_module 对应的文件内。</p>

<h4 id="使用方法">使用方法</h4>

<p>使用非常简单，主要有以下几点：</p>

<ul>
  <li>yarn add patch-package</li>
  <li>在 package.json 的 scripts 中加入 { “postinstall”: “patch-package” }，这是 npm 脚本命令的钩子，会在依赖包被 install 之后执行。（npm 还提供 prepublish，postpublish，preinstall 等默认钩子）</li>
  <li>生成补丁。例如，修改 lodash 库后，执行命令 <code class="highlighter-rouge">yarn patch-package lodash</code>，默认在项目根目录生成<code class="highlighter-rouge">patches</code>目录，里面存放的就是‘补丁’</li>
</ul>

<p>现在，你把<code class="highlighter-rouge">node_module</code>目录删掉之后，重新安装依赖，你会发现<code class="highlighter-rouge">node_module</code>内的对应的源码还是你修改后的状态！</p>

<p>此外，运行 patch-package 还可配置参数：</p>

<ul>
  <li>–include &lt;regexp&gt; ： 创建补丁时忽略匹配的路径</li>
  <li>–exclude &lt;regexp&gt; ： 创建补丁时只考虑匹配的路径</li>
  <li>–patch-dir ： 补丁文件存放位置</li>
  <li>–reverse ： 回退所有补丁</li>
  <li>没有参数 ： 安装补丁到 node_module 目录中</li>
</ul>
:ET